<h2 class="text-warning text-center">Super Mario Bros</h2>
<br>
<br>
<br>

<h3><i>Credits Warp</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/smb/disappearing-power-ups.gif">
<p>No Super Mario Bros, quando h√° mais de um power-up na tela (por exemplo, dois cogumelos ou uma flor de fogo), o 
    primeiro desaparece assim que o segundo aparece.
    Ou seja: 
    Voc√™ faz dois blocos com power-ups pr√≥ximos, e quando o segundo item sai do bloco, o primeiro simplesmente 
    some.</p>
<p>O Super Mario Bros foi feito para o NES, que tinha limita√ß√µes severas de hardware ‚Äî incluindo a quantidade de 
    sprites ativos simultaneamente e mem√≥ria dispon√≠vel para armazenar dados dos inimigos e objetos.
    O jogo tem uma lista de sprites ativos na mem√≥ria, onde cada slot guarda as informa√ß√µes de um objeto, como: 
    Tipo (Goomba, Fire Flower, etc.);
    Posi√ß√£o X/Y;
    Velocidade;
    Estado (ativo, coletado, etc.).
    Essa lista tem n√∫mero limitado de slots (geralmente 5).
    E ‚Äî muito importante ‚Äî os power-ups compartilham o mesmo slot de ‚Äúobjeto especial‚Äù.
    Ent√£o:
    Quando o primeiro power-up √© criado, ele usa o slot reservado.
    Quando o segundo power-up √© gerado, ele substitui o anterior, fazendo o primeiro desaparecer.</p>
<p>O problema √© que o c√≥digo n√£o permite mais de um power-up ativo ao mesmo tempo ‚Äî por design, n√£o por bug 
    acidental.
    Isso economizava mem√≥ria e processamento no NES, que tinha apenas 2 KB de RAM e muito pouco espa√ßo de sprite 
    rendering.
    Mas, do ponto de vista do jogador, isso se manifesta como um glitch visual, j√° que o primeiro item ‚Äúdesaparece 
    magicamente‚Äù sem motivo aparente.</p>
<br>
<br>

<h3><i>Frozen flag</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/smb/SMB_Flagpole_Glitch.gif">
<p>Normalmente, quando Mario encosta no mastro da bandeira (flagpole) no final da fase: 
    A bandeira desce.
    Mario escorrega para o ch√£o.
    O jogo toca a m√∫sica e corta o controle do jogador.
    O timer para e a pontua√ß√£o √© calculada.
    No glitch conhecido como Frozen Flag, Mario encosta no mastro, mas a bandeira n√£o desce ‚Äî ela fica congelada 
    no topo.
    Apesar disso, o jogo reconhece o toque no mastro e faz Mario seguir para o castelo como se tudo estivesse 
    normal.</p>
<p>No Super Mario Bros, o final da fase √© controlado por um c√≥digo de evento que depende de colis√µes e posi√ß√µes 
    espec√≠ficas: 
    Quando Mario colide com o tile do mastro, o jogo define uma flag na mem√≥ria: 
    <p>MarioTouchedFlagpole = true</p>
    Em seguida, o jogo ativa a anima√ß√£o da bandeira descendo e muda o estado de Mario para ‚Äúflagpole slide‚Äù.
    A cada frame, o jogo move a bandeira 1 pixel para baixo at√© atingir o limite.
    Quando a bandeira chega ao fim, o jogo:
    Faz Mario andar automaticamente at√© o castelo.
    Faz o timer parar e o jogo prepara a pr√≥xima fase.</p>
<p>O Frozen Flag Glitch quebra essa sequ√™ncia porque Mario ativa o evento de toque no mastro, mas nunca realmente aciona o evento da bandeira descendo.
    Isso acontece quando Mario colide com o tile da bandeira e o bloco do mastro ao mesmo tempo, ou seja, duas colis√µes na mesma frame.
    O jogo, ent√£o: 
    <p>Define a flag MarioTouchedFlagpole = true </p>
    <p>Mas nunca define a flag FlagShouldMove = true</p>
    O resultado: 
    Mario entra na anima√ß√£o normal do final de fase (como se tivesse descido o mastro),
    Mas a bandeira fica congelada no topo ‚Äî o ‚ÄúFrozen Flag‚Äù.</p>
<p>O NES √© um sistema frame-based, ou seja, tudo acontece em ciclos muito r√°pidos (60 vezes por segundo).
    No exato frame em que o glitch √© executado:
    Mario est√° posicionado entre dois blocos: o do mastro e o bloco lateral do castelo.
    O motor de colis√£o do jogo l√™ as colis√µes de cima para baixo.
    Como Mario ‚Äúentra‚Äù no mastro pelo canto, o jogo registra o toque mas pula a rotina de movimentar a bandeira, 
    porque o c√≥digo de detec√ß√£o de colis√£o n√£o espera que ele toque o mastro dessa forma.
    O c√≥digo mais ou menos faz isso:
    <p>if MarioTouchesFlagpole then</p>
    <p>SetMarioSliding()</p>
    <p>MoveFlagDown()</p>
    Mas no glitch, o segundo comando (MoveFlagDown()) √© pulado, porque a posi√ß√£o de Mario sai da √°rea da flagpole 
    antes do pr√≥ximo frame.
    Isso faz com que: 
    A bandeira nunca receba atualiza√ß√£o de posi√ß√£o.
    O jogo ainda interprete o toque como v√°lido e inicia o fim da fase.
    O tempo e a movimenta√ß√£o de Mario funcionem normalmente.</p>
<p>H√° uma varia√ß√£o do glitch onde o jogador usa um Bullet Bill (proj√©til) para ser empurrado at√© o mastro:
    Quando o Bullet Bill empurra Mario no frame certo, ele toca o mastro sem que o jogo detecte o contato 
    completo com a bandeira.
    Isso aciona o evento de final de fase (Mario come√ßa a andar sozinho e o tempo conta para pontua√ß√£o),
    Mas, novamente, a bandeira n√£o se move, permanecendo congelada.</p>
<br>
<br>

<h3><i>Minus World</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/smb/SMB_How_to_Get_to_Minus_World.gif">
<p>O Minus World √© uma fase secreta e infinita de Super Mario Bros, acessada a partir do Mundo 1-2 por meio de um glitch.
    Quando o jogador executa o truque corretamente, ele entra em um cano que o leva para uma fase chamada 
    ‚ÄúWorld -1‚Äù (ou ‚ÄúWorld 36-1‚Äù em algumas vers√µes).
    Essa fase √©, na verdade, uma c√≥pia corrompida do Mundo 7-2, mas com o destino de sa√≠da configurado 
    incorretamente ‚Äî o que faz o jogo recarregar a mesma fase infinitamente, prendendo o jogador para sempre.</p>
<p>No Mundo 1-2, o jogador deve: 
    Ir at√© o fim da fase, onde h√° o cano de sa√≠da para a superf√≠cie.
    Quebrar os blocos acima desse cano.
    Pular de um jeito espec√≠fico para ‚Äúatravessar‚Äù a parede sem realmente entrar no cano normalmente.
    Se feito com o timing certo, Mario entra parcialmente no cano pelo lado, e o jogo confunde de qual tubo ele 
    est√° saindo.
    O resultado: 
    O jogo tenta carregar o n√≠vel associado ao cano de sa√≠da, mas usa o endere√ßo de mem√≥ria errado ‚Äî levando 
    Mario ao ‚ÄúMundo -1‚Äù.</p>
<p>No Super Mario Bros, os canos de transi√ß√£o (os que levam a outros lugares) s√£o definidos por tabelas de 
    destino na mem√≥ria.
    Quando Mario entra em um cano, o jogo faz o seguinte:
    L√™ a posi√ß√£o de Mario no mapa.
    Procura na tabela o √≠ndice do cano correspondente.
    Usa esse √≠ndice para: 
    Carregar o ID da pr√≥xima fase.
    Definir a posi√ß√£o inicial.
    Mudar o mundo e n√≠vel na tela (ex: 1-2 ‚Üí 1-3).
    Mas‚Ä¶ 
    quando o glitch √© ativado, Mario entra em um cano ‚Äúpor fora‚Äù, sem que o √≠ndice correto seja definido.
    O jogo, ent√£o: 
    L√™ dados de mem√≥ria aleat√≥rios (garbage data).
    Interpreta esses bytes como o ID do mundo e do n√≠vel.
    Exibe o texto ‚ÄúWorld -1‚Äù, porque o byte lido corresponde ao valor 255 (0xFF), que o jogo interpreta como -1 
    em n√∫mero com sinal.</p>
<p>O motor de colis√£o e warp do jogo foi feito com a suposi√ß√£o de que Mario sempre entraria corretamente por cima 
    do cano.
    Quando ele entra pelo lado, o c√≥digo que define o cano ativo nunca √© executado, e o jogo acaba usando valores 
    residuais na mem√≥ria ‚Äî ou seja, o √∫ltimo dado v√°lido armazenado.
    Em termos simples:</p>
    <p>if MarioEnteredPipe then</p>
        <p>LoadPipeDestinationData()</p>
    <p>else</p>
        <p>UsePreviousValuesInRAM()</p>
    No glitch, o LoadPipeDestinationData() nunca √© chamado, e o jogo usa o que j√° estava na RAM ‚Äî geralmente 
    bytes da fase atual (1-2), interpretados como um destino inv√°lido.
    Esses bytes apontam para: 
    O layout da fase 7-2, mas
    Um warp que leva de volta a si mesmo ‚Üí criando o loop infinito</p>
<p>No ‚ÄúMinus World‚Äù, o n√≠vel que o jogo carrega tem uma porta de sa√≠da incorreta (por causa dos dados corrompidos).
    Quando voc√™ tenta sair da fase, o jogo: 
    Usa o mesmo valor de destino que j√° est√° na RAM,
    E recarrega o mesmo n√≠vel novamente.
    Isso cria o loop infinito que prende Mario para sempre.</p>
<p>Na vers√£o japonesa (Famicom Disk System), o Minus World √© diferente ‚Äî s√£o tr√™s fases distintas, e √© poss√≠vel 
    termin√°-las normalmente.
    O nome ‚ÄúWorld -1‚Äù vem do fato de o byte 255 (0xFF) ser interpretado como -1 em n√∫meros com sinal.
    √â um erro leg√≠timo de leitura de mem√≥ria, n√£o algo programado de prop√≥sito.
    Em ROM hacks e ports modernos, o glitch muitas vezes foi corrigido ou usado propositalmente como easter egg.</p>
<br>
<br>

<h3><i>Mushroom jump glitch</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/smb/SMB_Jumping_in_Midair_Glitch.gif">
<p>O jogador precisa pegar um power-up (Cogumelo ou Flor de Fogo) enquanto est√° no ar ‚Äî por exemplo, saltando para 
    tocar o item.
    No exato momento em que Mario entra na anima√ß√£o de transforma√ß√£o, o jogo congela temporariamente o controle 
    do jogador, mas mant√©m o √∫ltimo comando de bot√£o registrado.
    Se o jogador pressionar o bot√£o de pulo (A ou B) durante essa transi√ß√£o, o jogo ‚Äúlembra‚Äù do comando, mas s√≥ 
    aplica o efeito depois que a transforma√ß√£o termina.
    Quando o jogo retoma o controle normal, ele executa o comando de pulo armazenado ‚Äî mesmo que Mario n√£o esteja 
    tocando o ch√£o ‚Äî e isso faz com que ele salte no ar, criando o ‚Äúsalto duplo‚Äù ilus√≥rio.</p>
<p>O glitch acontece por causa de uma falha na rotina de atualiza√ß√£o de estados de Mario no c√≥digo do jogo:
    Durante a anima√ß√£o de transforma√ß√£o, o jogo pausa a f√≠sica (gravidade e colis√µes) de Mario.
    No entanto, o registrador de entrada de bot√µes ainda √© atualizado.
    O comando de pulo √© armazenado em uma vari√°vel tempor√°ria antes que o estado de ‚Äúem transforma√ß√£o‚Äù bloqueie 
    os movimentos.
    Quando o estado volta a ‚Äúnormal‚Äù, essa vari√°vel n√£o √© redefinida imediatamente, fazendo com que o pulo 
    aconte√ßa sem verificar se Mario est√° no ch√£o.
    Em resumo: o jogo ‚Äúesquece‚Äù de verificar se Mario pode pular antes de executar o comando armazenado.</p>
<p>Se o glitch for feito com uma Flor de Fogo, o som do tiro de fireball substitui o som do pulo, porque o jogo 
    ainda est√° em meio √† sequ√™ncia de transforma√ß√£o e tenta tocar os dois sons quase ao mesmo tempo.
    O glitch tamb√©m est√° presente em Super Mario All-Stars, pois o motor de jogo recriado para o SNES mant√©m a 
    mesma l√≥gica de transforma√ß√£o.</p>
<br>
<br>

<h3><i>Over the flagpole</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/smb/SMB_W3-3_Glitch1.gif">
<p>Em condi√ß√µes normais, o final de uma fase de Super Mario Bros. √© limitado por dois elementos:
    O mastro da bandeira (flagpole), que detecta colis√£o com Mario.
    Um bloco invis√≠vel (invisible wall) posicionado no topo da escada, para evitar que o jogador pule acima da 
    bandeira.
    O glitch ocorre em fases onde esse bloco invis√≠vel n√£o foi posicionado corretamente ‚Äî ou seja, h√° espa√ßo 
    suficiente entre o topo da escada e o limite superior da tela para Mario saltar por cima da bandeira, 
    escapando da ‚Äúzona de t√©rmino‚Äù da fase.</p>
<p>O jogo foi programado para: 
    Detectar o t√©rmino da fase somente quando Mario colide com o mastro da bandeira.
    N√£o criar uma barreira f√≠sica ap√≥s o mastro ‚Äî o cen√°rio simplesmente continua.
    Ou seja: 
    Nada impede Mario de continuar andando ap√≥s o mastro.
    O jogo nunca verifica se o jogador passou ‚Äúdo fim‚Äù porque, tecnicamente, o mastro √© o fim.
    Ent√£o, quando o jogador consegue subir alto o suficiente (geralmente usando escadas ou plataformas m√≥veis) e 
    pular al√©m do topo do mastro, ele entra em uma √°rea onde:
    N√£o h√° colis√µes programadas;
    N√£o h√° eventos de t√©rmino de fase;</p>
<p>A rotina de colis√£o com o mastro funciona assim:
    <p>IF (Mario.x == Flagpole.x) AND (Mario.y >= FlagBase)</p>
        <p>-> Iniciar sequ√™ncia de t√©rmino da fase</p>
    Mas o jogo n√£o verifica se Mario ultrapassou Flagpole.x sem colidir ‚Äî ent√£o se o jogador passa direto, a flag 
    nunca √© ativada e o jogo continua.
    Al√©m disso, o flagpole √© um sprite, n√£o um objeto s√≥lido. Ele s√≥ serve para detectar colis√£o ‚Äî ent√£o o espa√ßo 
    acima dele √© ‚Äúlivre‚Äù.
    Se o jogador atinge esse espa√ßo com um salto suficientemente alto (como no World 1-1 ou 3-3), ele escapa da 
    colis√£o completamente.</p>
<p>No famoso caso da fase 1-1, o truque usa a f√≠sica de um Koopa Troopa que cai e fica parcialmente travado no ch√£o.
    Isso muda a forma como o jogo atualiza as colis√µes no topo da escada ‚Äî permitindo que Mario atinja um ponto 
    de salto mais alto do que o normal.
    Ao realizar o salto preciso: 
    Mario entra em uma posi√ß√£o de pixel exata onde o bloco invis√≠vel n√£o existe.
    O jogo o coloca acima do topo da bandeira, permitindo ultrapassar o limite.</p>
<p>Ap√≥s o mastro, o jogo n√£o cont√©m mais eventos, blocos ou colis√µes significativas:
    O ch√£o se estende continuamente com tiles repetidos.
    N√£o h√° c√≥digo para encerrar a fase automaticamente.
    O fundo e os blocos come√ßam a se ‚Äúembaralhar‚Äù graficamente ap√≥s certo ponto, pois o mapa de tiles n√£o tem 
    dados carregados al√©m da zona final.
    Por isso, o jogador s√≥ pode: 
    Correr infinitamente at√© o tempo acabar, ou
    Usar cheats para continuar e ver os gr√°ficos corrompidos no final da √°rea.</p>
<br>
<br>

<h3><i>Red Shell out of thin air</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/smb/SMB_W4-1_Glitch1.gif">
<p>No caso mais comum (Mundo 3-1):
    O jogador encontra um Koopa Troopa verde andando abaixo de um conjunto de blocos de tijolo.
    Mario acerta o bloco por baixo, atingindo o Koopa por meio da colis√£o.
    O Koopa √© derrotado e se transforma em um casco verde virado de cabe√ßa para baixo.
    Poucos quadros depois, o jogo come√ßa a atualizar o estado desse Koopa para faz√™-lo sair do casco.
    Se, nesse exato momento, o jogador acerta novamente o mesmo bloco, o jogo tenta acessar o mesmo espa√ßo de 
    mem√≥ria do Koopa ‚Äî mas com uma rotina diferente (a dos blocos), o que altera os dados do inimigo na RAM.
    O valor hexadecimal que representa ‚ÄúKoopa verde‚Äù (por exemplo 02) √© sobrescrito por outro valor (como 03), que 
    o jogo interpreta como ‚ÄúKoopa vermelho‚Äù.
    Resultado: o casco muda de cor ou surge como um casco vermelho novo ‚Äúdo nada‚Äù.</p>
<p>Esse glitch √© um caso cl√°ssico de corrup√ß√£o de dados tempor√°rios na RAM do NES.
    O Super Mario Bros. usava uma tabela de sprites limitada, onde cada inimigo ativo era controlado por um slot 
    de mem√≥ria contendo informa√ß√µes.</p>
<p>Quando o jogador acerta um bloco, o jogo tamb√©m usa os mesmos registradores tempor√°rios para controlar o 
    movimento do bloco e os efeitos gr√°ficos (como moedas ou power-ups).
    O erro ocorre porque: 
    O jogo n√£o ‚Äúlimpa‚Äù a mem√≥ria tempor√°ria antes de reutiliz√°-la para outro prop√≥sito.
    Se o tempo de execu√ß√£o entre as duas a√ß√µes (Koopa sendo atingido e bloco sendo ativado) coincide exatamente, 
    os dados do Koopa s√£o parcialmente sobrescritos pelos dados do bloco.
    Esses bytes modificados mudam o ‚ÄúID do inimigo‚Äù, transformando-o em um casco vermelho, um Spiny Egg, ou outro 
    objeto definido no mapa de sprites.</p>
<p><p>; Pseudoc√≥digo simplificado</p>
    <p>Koopa.type = GREEN   ; 02h</p>
    <p>If (blockHit && Koopa.state == recovering)</p>
        <p>Koopa.type = valueFrom(blockRoutine) ; sobrescreve 02h ‚Üí 03h</p>
    Isso gera a troca visual e comportamental: 
    O sprite verde passa a ser vermelho,
    E o jogo n√£o sabe que isso √© um erro ‚Äî apenas exibe o novo tipo normalmente.</p>
<p>Mundos 4-1 e 6-1:
    O glitch tamb√©m ocorre quando um Spiny Egg lan√ßado por um Lakitu cai exatamente sobre um bloco que Mario 
    acerta.
    O mesmo conflito de atualiza√ß√£o acontece: o jogo tenta atualizar o Spiny Egg e o bloco no mesmo quadro, 
    resultando na cria√ß√£o de um casco vermelho.
    Super Mario All-Stars (SNES): 
    Mesmo sendo uma vers√£o reprogramada, o glitch permanece ‚Äî porque a l√≥gica de gerenciamento de inimigos e 
    blocos foi mantida fiel ao original.</p>
<br>
<br>

<h3><i>Jumping damage glitch</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/smb/SMB_Jumping_Damage_Glitch.gif">
<p>O jogador vai at√© a √°rea do World 1-1 com os dois Goombas e um buraco logo depois dos blocos altos.
    Ele deve subir nos blocos, esperar os Goombas aparecerem, e ent√£o: 
    Recuar levemente.
    Esperar o primeiro Goomba se aproximar do buraco.
    Correr e pular da beirada no momento certo.
    Se o tempo for exatamente perfeito, Mario sobe t√£o alto que sua posi√ß√£o vertical sai momentaneamente da √°rea 
    vis√≠vel da tela (off-screen).
    Nesse breve instante, o jogo l√™ incorretamente os valores de posi√ß√£o vertical e colis√£o, interpretando que 
    Mario entrou em contato com o Goomba ‚Äî mesmo sem toc√°-lo visualmente.
    O resultado √© que Mario morre instantaneamente (se for pequeno) ou perde o power-up (se for Super Mario), 
    como se tivesse colidido com o inimigo.</p>
<p>Esse glitch √© resultado de uma falha no c√°lculo de coordenadas entre a posi√ß√£o do jogador e a posi√ß√£o dos 
    inimigos, causada pelo overflow de posi√ß√£o vertical (Y) quando Mario sai da tela superior.
    Em termos t√©cnicos: 
    O Super Mario Bros. armazena as posi√ß√µes verticais e horizontais de Mario e dos inimigos em valores de 8 bits 
    (0‚Äì255).
    Quando Mario salta alto o suficiente para sair da tela, o valor de sua coordenada Y ultrapassa o limite 
    m√°ximo (255).
    O processador reinicia o valor (overflow), fazendo parecer que Mario est√° abaixo do ch√£o na mesma posi√ß√£o Y 
    que o Goomba.
    Como o jogo s√≥ verifica se as caixas de colis√£o (hitboxes) de Mario e do inimigo t√™m coordenadas pr√≥ximas, 
    ele ‚Äúacredita‚Äù que houve contato ‚Äî e aplica dano.</p>
<p><p>Mario.Y = 255 (m√°ximo)</p>
    <p>Mario salta ‚Üí Mario.Y = 260</p>
    <p>Mas o valor 260 n√£o existe ‚Üí volta a 4 (overflow)</p>
    <p>Goomba.Y = 4</p>
    <p>‚Üí Jogo acha que Mario e Goomba se tocaram</p>
    <p>‚Üí Dano aplicado</p>
    Ou seja: o jogo literalmente ‚Äúpensa‚Äù que Mario caiu em cima do inimigo, quando na verdade ele est√° acima da 
    tela.</p>
<p>Esse glitch n√£o pode acontecer em qualquer ponto da fase, porque: 
    Depende de um Goomba ou inimigo ativo na mem√≥ria, pr√≥ximo o suficiente horizontalmente.
    Precisa que Mario suba acima do topo da tela, o que s√≥ ocorre com blocos altos e pulo preciso.
    O c√°lculo de colis√£o s√≥ √© executado se ambos estiverem ‚Äúcarregados‚Äù no mesmo segmento de mem√≥ria ‚Äî se o 
    inimigo estiver muito longe, o glitch n√£o acontece.
    O trecho de World 1-1 atende a todas essas condi√ß√µes, por isso ele √© o local cl√°ssico para realizar o glitch.</p>
<br>
<br>

<h3><i>Magic Mushroom glitch</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/smb/SMB_W1-1_Glitch2.gif">
<p>Em World 1-1, h√° um trecho onde um ? Block libera um Mushroom perto de um buraco (gap).
    O jogador deve estar na forma pequena (Small Mario) e bater no bloco para liberar o cogumelo.
    O cogumelo ent√£o anda para o lado e cai no buraco, desaparecendo da tela.
    O jogador, logo em seguida, pula para o topo da tela (no n√≠vel dos blocos).
    Se o tempo for exato, Mario se transforma em Super Mario, mesmo sem ter tocado o cogumelo visivelmente.</p>
<p>O erro acontece por causa de como o NES gerencia a posi√ß√£o vertical dos objetos (sprites) em Super Mario 
    Bros., sem rolagem vertical.
    O jogo s√≥ ‚Äúapaga‚Äù (ou descarrega) um objeto quando o √∫ltimo pixel do sprite sai completamente da √°rea vis√≠vel 
    da tela.
    At√© esse momento, o objeto continua existindo logicamente na mem√≥ria, mesmo que n√£o seja mais desenhado na 
    tela.</p>
<p>Quando o Mushroom come√ßa a cair no buraco: 
    Ele ainda tem coordenadas v√°lidas (Y = 239, o limite inferior da tela).
    O jogo ainda o considera ativo, porque apenas verifica se ele saiu totalmente da tela.
    Enquanto o cogumelo est√° nessa ‚Äúzona invis√≠vel‚Äù, o jogo ainda verifica colis√µes horizontais com Mario.
    Se Mario estiver acima da tela (por exemplo, pulando sobre os blocos), a rotina de colis√£o n√£o checa se ele 
    realmente v√™ o cogumelo ‚Äî ela s√≥ compara as coordenadas X e Y.
    Se ambas coincidirem por alguns pixels (o que pode ocorrer devido ao ‚Äúwrap‚Äù de posi√ß√£o vertical), o jogo 
    entende que houve contato, e aplica o efeito:
    <p>Mario.state = SUPER</p>
    <p>Play sound ‚Äúpower-up‚Äù</p>
    O resultado: Mario se transforma, mesmo que o cogumelo j√° tenha ‚Äúca√≠do no buraco‚Äù.</p>
<p>O Super Mario Bros. original n√£o tem rolagem vertical nas fases horizontais.
    Isso significa que:
    O jogo n√£o atualiza a posi√ß√£o dos sprites fora da √°rea vis√≠vel verticalmente.
    Se um objeto cai por baixo da tela, ele continua ‚Äúexistindo‚Äù at√© sumir totalmente.
    Esse espa√ßo √© uma esp√©cie de ‚Äúlimbo de colis√£o‚Äù, onde objetos invis√≠veis ainda podem interagir brevemente com 
    Mario.</p>
<p>Esse glitch s√≥ pode ocorrer em locais onde: 
    H√° um buraco logo abaixo de um ? Block com cogumelo, e
    Mario pode ficar no topo da tela, mantendo o mesmo alinhamento horizontal (X) do item.
    O ponto do World 1-1 √© perfeito, pois a borda superior e o buraco est√£o na dist√¢ncia exata para esse 
    comportamento acontecer antes que o cogumelo seja completamente descarregado da mem√≥ria.</p>
<br>
<br>

<h3><i>Sliding glitch</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/smb/SMB_Glitch_Unmovingmario.gif">
<p>Para ativar o glitch, o jogador deve: 
    Estar com o Fire Mario (Mario com flor de fogo).
    Assim que o n√≠vel come√ßar ‚Äî ou logo ap√≥s sair de um cano ‚Äî pular e atirar uma bola de fogo imediatamente.
    Se o tempo for exato, Mario poder√° se mover normalmente, mas seus p√©s n√£o se mexem, dando a impress√£o de que 
    ele est√° deslizando pelo ch√£o.
    O efeito dura apenas alguns segundos, ou at√© que Mario leve dano ou o jogo atualize novamente sua anima√ß√£o.</p>
<p>Esse glitch ocorre por uma falha na sincroniza√ß√£o das anima√ß√µes de movimento no momento em que o jogo carrega 
    o estado de Mario.
    Quando o jogador entra em uma nova √°rea, o jogo inicializa v√°rias vari√°veis, incluindo:
    A posi√ß√£o de Mario,
    Seu estado atual (normal, Super ou Fire),
    E a anima√ß√£o ativa (andar, pular, atirar, etc.).
    Ao pular e atirar exatamente nesse instante, o comando de disparar o fogo substitui a anima√ß√£o de andar antes 
    que ela seja corretamente ativada.
    O resultado: o jogo atualiza o deslocamento de Mario no mapa (ele anda), mas n√£o atualiza o sprite de suas 
    pernas, deixando-o com a mesma pose ‚Äî o que faz parecer que ele est√° ‚Äúdeslizando‚Äù.
    Em termos t√©cnicos, √© uma esp√©cie de race condition (condi√ß√£o de corrida): duas a√ß√µes ‚Äî carregar a anima√ß√£o e 
    disparar a bola de fogo ‚Äî acontecem quase ao mesmo tempo, e o jogo prioriza uma delas incorretamente.</p>
<p></p>
<br>
<br>

<h3><i>Vine teleportation</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/smb/Smb_vinewrap.gif">
<p>Esse glitch pode ser feito em qualquer parte de Super Mario Bros. onde h√° uma videira (vine) ‚Äî aquelas plantas 
    que Mario pode subir.
    O jogador deve subir a videira exatamente no canto esquerdo da tela, ou seja, quando ela est√° encostada na 
    borda vis√≠vel da tela.
    Ao tocar a videira nesse ponto e come√ßar a subir, Mario √© instantaneamente teletransportado para o lado 
    direito da tela.
    Ele continua subindo normalmente, mas agora aparece no lado oposto, como se tivesse ‚Äúatravessado‚Äù o mapa 
    horizontalmente.
    Esse glitch tamb√©m ocorre na vers√£o Super Mario All-Stars do SNES ‚Äî ou seja, mesmo o remake n√£o corrigiu o 
    problema.</p>
<p>O erro vem da maneira como Super Mario Bros. trata as coordenadas horizontais (a posi√ß√£o de Mario no eixo X).
    O jogo armazena a posi√ß√£o de Mario em um valor limitado, que representa sua localiza√ß√£o relativa √† tela, e 
    n√£o ao mundo inteiro.
    A √°rea vis√≠vel da tela vai de 0 (extrema esquerda) at√© 255 (extrema direita) ‚Äî isso porque o processador do 
    NES usa n√∫meros de 8 bits para guardar essas coordenadas.
    Quando Mario toca a videira exatamente no ponto X = 0, o jogo tenta calcular sua nova posi√ß√£o ao ‚Äúsubir‚Äù na 
    planta.
    S√≥ que, por um erro na rotina de c√°lculo, ele subtrai 1 desse valor (por exemplo, para ajustar a colis√£o).
    üëâ Mas como o valor j√° √© 0, e o NES trabalha com n√∫meros de 8 bits, ele ‚Äúd√° a volta‚Äù ‚Äî o valor passa de 0 
    para 255.
    Ou seja: 
    <p>0 - 1 = 255 (em 8 bits)</p>
    E o valor 255 representa o extremo direito da tela!
    Ent√£o o jogo entende que Mario est√° na outra ponta do mapa e o teletransporta para o lado direito.</p>
<p>Tipo de erro: overflow de coordenada em 8 bits.
    Causa: a posi√ß√£o X de Mario √© calculada de forma incorreta quando est√° no limite esquerdo.
    Efeito: o valor ‚Äúvolta‚Äù para o outro extremo da tela, criando o efeito de teletransporte.
    Corrigido? ‚ùå N√£o ‚Äî o glitch permanece at√© na vers√£o Super Mario All-Stars.</p>
<br>
<br>

<h3><i>Walking through walls</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/smb/SMB_Walking_Through_Walls_Glitch.gif">
<p>Esse glitch pode ser feito em praticamente qualquer fase que tenha paredes logo acima do ch√£o (ou seja, blocos 
    ou estruturas s√≥lidas que n√£o come√ßam diretamente no n√≠vel do piso).
    O jogador deve rolar a tela at√© que a parede desejada esteja parcialmente vis√≠vel, de forma que apenas metade 
    do corpo de Mario possa encaixar-se nela.
    Ent√£o, o jogador precisa pular e pressionar o bot√£o direcional para a esquerda, repetidamente.
    Se feito com o tempo e a posi√ß√£o corretos, Mario ‚Äúescorrega‚Äù para dentro da parede, atravessando o bloco e 
    podendo at√© acessar √°reas normalmente inalcan√ß√°veis ‚Äî como o teto das fases de castelo.</p>
<p>O bug vem do funcionamento interno do sistema de detec√ß√£o de colis√£o do NES, que √© muito simples para 
    economizar processamento.
    Normalmente, o jogo faz o seguinte a cada quadro: 
    Move Mario horizontalmente (com base na press√£o do direcional).
    Depois, verifica se Mario est√° colidindo com algum bloco s√≥lido.
    Se sim, ele empurra Mario para fora da parede ‚Äî geralmente, um pixel de cada vez ‚Äî at√© que n√£o haja 
    sobreposi√ß√£o.
    O problema √© que, ao pular e pressionar contra a parede, o jogo √†s vezes atualiza a posi√ß√£o vertical de Mario 
    antes da horizontal, ou vice-versa, dependendo do quadro.
    Quando isso acontece: 
    Mario pode ficar ‚Äúencaixado‚Äù dentro do canto do bloco por alguns frames;
    O c√≥digo de corre√ß√£o de colis√£o tenta empurr√°-lo na dire√ß√£o errada (geralmente para dentro, e n√£o para fora);
    O resultado √© que Mario atravessa o bloco inteiro, emergindo do outro lado como se tivesse ‚Äúpassado por 
    dentro da parede‚Äù.
    Esse comportamento √© acentuado quando a tela n√£o est√° totalmente rolada ‚Äî ou seja, quando o jogador tenta 
    atravessar uma parede que est√° no limite esquerdo da c√¢mera, pois as coordenadas de colis√£o ficam 
    parcialmente fora da √°rea ativa de verifica√ß√£o.</p>
<p>Tipo de erro: falha de sincroniza√ß√£o no sistema de detec√ß√£o de colis√µes.
    Causa: ordem incorreta de atualiza√ß√£o entre movimento horizontal e vertical, aliada ao posicionamento na 
    borda da tela.
    Efeito: Mario atravessa paredes s√≥lidas, podendo chegar a partes ocultas ou ao teto das fases.
    Corrigido? ‚ùå N√£o ‚Äî o glitch existe nas vers√µes originais do NES e tamb√©m em Super Mario All-Stars.</p>
<br>
<br>

<h3><i>Wall jump glitch</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/smb/SMB_Wall_Jump_Glitch.gif">
<p>Durante o jogo: 
    Mario deve estar se movendo em dire√ß√£o a uma parede ou tubo com velocidade suficiente.
    Quando ele toca a parede no momento exato em que est√° caindo ou deslizando, o jogo reconhece por um √∫nico 
    frame (1/60 de segundo) que seu p√© ‚Äúencostou‚Äù em uma superf√≠cie s√≥lida.
    Se o jogador pressionar o bot√£o de pulo nesse exato frame, Mario executa um salto completo, mesmo estando 
    encostado lateralmente ‚Äî o que √© imposs√≠vel em condi√ß√µes normais.
    O resultado visual √© que Mario salta para longe da parede, como se usasse ela de apoio ‚Äî exatamente como em 
    jogos modernos que t√™m o wall jump como mec√¢nica proposital.</p>
<p>Para entender o motivo, √© preciso olhar como o NES tratava o c√°lculo de colis√µes em Super Mario Bros..
    O mapa √© feito de blocos individuais, e cada um √© testado separadamente para saber se √© s√≥lido. Quando Mario 
    encosta em uma parede: 
    O jogo tenta ‚Äúempurrar‚Äù Mario para fora da parede um pixel por vez, at√© que n√£o haja sobreposi√ß√£o.
    Por√©m, durante esse processo, parte do sprite de Mario pode invadir ligeiramente o bloco (1 pixel ou menos).
    Se esse pixel ‚Äúinvadido‚Äù estiver na altura do p√© de Mario, o jogo registra momentaneamente que h√° uma 
    superf√≠cie s√≥lida abaixo dele ‚Äî como se ele estivesse de p√©.
    Ou seja, por um instante min√∫sculo, o jogo acha que h√° ch√£o onde na verdade h√° uma parede.
    Se o jogador pressiona o bot√£o de pulo nesse frame, o c√≥digo de salto √© ativado, permitindo que Mario salte 
    ‚Äúa partir‚Äù da parede.
    Esse comportamento √© consistente em v√°rios jogos 2D da era 8-bit e 16-bit, pois todos reutilizavam uma vers√£o 
    semelhante do c√≥digo de colis√£o da Nintendo, o que explica por que o mesmo glitch aparece tamb√©m em: 
    Super Mario Bros. 3, 
    Super Mario World, 
    Super Mario World 2: Yoshi‚Äôs Island</p>
<p>Tipo de erro: falha na detec√ß√£o de colis√£o lateral (hitbox x tilemap).
    Causa: o jogo registra erroneamente uma ‚Äúsuperf√≠cie de apoio‚Äù no momento em que Mario encosta lateralmente em 
    um bloco.
    Efeito: permite que Mario pule de paredes ou tubos, mesmo sem haver uma plataforma.
    Corrigido? ‚ùå N√£o ‚Äî o comportamento persiste at√© Super Mario World, onde o sistema de colis√£o ainda permitia 
    pequenos erros de posi√ß√£o por pixel.</p>
<br>
<br>

