<h2 class="text-warning text-center">Paper Mario</h2>
<br>
<br>
<br>

<h3><i>Captured as a Koopatrol</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/pm/200px-Koopatrol_Peach.png">
<p>Durante o interl√∫dio do Cap√≠tulo 6, Peach pode usar o Sneaky Parasol para se transformar em um Koopatrol (os guardas do castelo).

Se o jogador usar o Parasol exatamente no momento em que um Koopatrol a detecta, ocorre uma sobreposi√ß√£o de eventos:

O jogo registra que Peach foi pega.

Mas tamb√©m aplica a transforma√ß√£o de disfarce antes da captura terminar.

O resultado √© que:

Peach aparece visualmente como um Koopatrol,

Mas o jogo ainda a reconhece internamente como Peach.

Ent√£o, os pr√≥prios guardas ‚Äúcapturam‚Äù a Koopatrol (Peach disfar√ßada) e a levam de volta ao quarto, tratando-a como se fosse Peach sem disfarce.

Esse mesmo comportamento tamb√©m pode ser observado com um Hammer Bro na biblioteca, j√° que o modelo do Koopatrol n√£o possui todas as anima√ß√µes de ‚Äúcaptura‚Äù programadas.</p>
<p>Esse glitch ocorre por causa de um erro de timing e prioriza√ß√£o de eventos na engine do jogo:

O jogo executa dois scripts simultaneamente ‚Äî o da detec√ß√£o de Peach e o da transforma√ß√£o com o Parasol.

O sistema de captura foi programado para reconhecer apenas o status ‚ÄúPeach‚Äù, sem verificar se ela est√° disfar√ßada.

Como resultado, o estado de disfarce √© mantido no modelo visual, mas a l√≥gica de captura continua ativa, levando os guardas a cumprir o script normal.

A aus√™ncia de certas anima√ß√µes (como a de ‚Äúser levada enquanto disfar√ßada‚Äù) faz com que o jogo use sprites incorretos ou reaproveite frames errados, causando o efeito de Peach sendo levada enquanto ainda parece um Koopatrol.

Al√©m disso, se o glitch for feito fora do Cap√≠tulo 6 (usando sequence breaks), os guardas n√£o t√™m c√≥digo para reagir √† Peach disfar√ßada, ent√£o sempre a capturam, independentemente da forma que ela assuma.</p>
<p>Em resumo:
‚û°Ô∏è O glitch funciona porque o jogo n√£o consegue decidir se Peach √© um Koopatrol ou ela mesma.
‚û°Ô∏è E funciona dessa forma porque os scripts de detec√ß√£o e transforma√ß√£o acontecem ao mesmo tempo, sem uma verifica√ß√£o que bloqueie um deles.</p>
<br>
<br>

<h3><i>Herringway glitch</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/pm/120px-Herringway_Bumpty.png">
<img width="70%" src="./src/assets/images/glitchesEBugs/pm/120px-Herringway_Invisible.png">
<img width="70%" src="./src/assets/images/glitchesEBugs/pm/120px-HerringwayGlitch.png">
<p>O Herringway glitch em Paper Mario 64 √© um erro curioso que afeta o comportamento de um personagem importante do Cap√≠tulo 7 ‚Äî o Herringway, um escritor pinguim que ajuda Mario a investigar um ‚Äúcrime‚Äù em Shiver City. Esse glitch faz com que ele mude de forma, desapare√ßa ou at√© congele o jogo, dependendo do momento e da vers√£o do jogo.</p>
<p>O evento ocorre quando Mario e Herringway entram na sala do Prefeito ‚Äî uma cena programada com movimentos e falas autom√°ticas.

Se o jogador pausar o jogo no exato momento em que o evento come√ßa (logo ap√≥s abrir a porta ou antes de o di√°logo com o detetive iniciar), o jogo interrompe o script de evento, congelando parcialmente a sequ√™ncia de transforma√ß√µes e anima√ß√µes.

Quando o jogo √© retomado:

Herringway pode assumir o modelo de um pinguim comum,

ou ficar totalmente invis√≠vel.</p>
<p>Esse glitch ocorre por causa de um conflito entre o sistema de scripts de evento e o carregamento de sprites (modelos visuais) ‚Äî algo comum em jogos Nintendo 64 que usavam scripts sequenciais.

Vamos dividir o que acontece internamente:

üß© 1. O jogo carrega o modelo ‚ÄúHerringway‚Äù com estados espec√≠ficos

Durante a cena, Herringway n√£o √© um NPC gen√©rico ‚Äî ele tem modelos e anima√ß√µes √∫nicas, como express√µes faciais e frames de ‚Äúcarregar presente‚Äù.

üß© 2. Pausar interrompe o script de inicializa√ß√£o

Quando o jogador pausa, o script da cutscene √© congelado no meio da execu√ß√£o, mas o estado do personagem (como o modelo em uso) pode ficar inconsistente.
Isso faz com que o jogo substitua o modelo personalizado de Herringway pelo modelo padr√£o de ‚Äúpenguin.npc‚Äù ou o deixe sem modelo vis√≠vel.

üß© 3. O resultado depende da vers√£o do jogo:

üïπÔ∏è Vers√£o original do Nintendo 64:
Quando o modelo de pinguim comum √© usado, o jogo tenta aplicar a anima√ß√£o especial de ‚Äúentregar presente‚Äù ‚Äî que esse modelo n√£o possui.
Isso causa um erro fatal, travando o jogo e exibindo uma tela de debug (uma ferramenta interna usada pelos desenvolvedores para identificar falhas).

üíª Vers√£o Virtual Console (Wii):
A Nintendo removeu o c√≥digo de debug e melhorou a toler√¢ncia a erros.
Ent√£o, em vez de travar, o jogo apenas faz Herringway desaparecer momentaneamente durante as anima√ß√µes problem√°ticas, ou o mostra com uma express√£o ‚Äúfeliz‚Äù e asas se movendo rapidamente, devido a quadros de anima√ß√£o incorretos sendo lidos.</p>
<p>‚û°Ô∏è O glitch funciona porque pausar o jogo interrompe o script de evento antes de ele carregar corretamente o modelo de Herringway.
‚û°Ô∏è E ele acontece dessa forma porque o jogo tenta continuar o evento com dados incompletos ‚Äî o que faz o modelo ser trocado, desaparecer ou causar falha na execu√ß√£o.</p>
<br>
<br>

<h3><i>Shiver City pond glitch</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/pm/120px-PM_Shiver_City_pond_glitch_1.png">
<img width="70%" src="./src/assets/images/glitchesEBugs/pm/120px-PM_Shiver_City_pond_glitch_2.png">
<img width="70%" src="./src/assets/images/glitchesEBugs/pm/120px-PM_Shiver_City_pond_glitch_3.png">
<p>O Shiver City Pond Glitch em Paper Mario 64 √© um dos glitches mais t√©cnicos e fascinantes do jogo, pois ele mexe diretamente com como o jogo controla o estado de objetos no mapa ‚Äî neste caso, o lago congelado de Shiver City. Ele mostra claramente como o jogo usa valores num√©ricos simples (bytes) para representar mudan√ßas visuais e f√≠sicas no ambiente, e o que acontece quando o jogador manipula isso de forma n√£o intencional.</p>
<p>Quando Mario chega em Shiver City, h√° um lago congelado que pode ser rachado usando o Tornado Jump.

Normalmente:

Ap√≥s o primeiro salto, o gelo mostra pequenas rachaduras.

Ap√≥s o segundo salto, o gelo quebra completamente, e os pinguins aparecem e expulsam Mario da √°rea.

Ao retornar, o lago √© resetado, ficando congelado novamente.

No glitch, o jogador usa uma t√©cnica chamada loading zone storage, que interrompe o teleporte (ou ‚Äútransi√ß√£o de mapa‚Äù) para que Mario saia do mapa no exato momento em que o jogo tenta expuls√°-lo.

Isso impede que o jogo execute o comando que restaura o estado do lago, ent√£o, ao retornar, o gelo permanece rachado.
Assim, o jogador pode continuar usando Tornado Jump para incrementar o contador de rachaduras al√©m do limite normal.</p>
<p>O jogo controla o estado do lago congelado com uma √∫nica vari√°vel (um byte, ou seja, um n√∫mero que vai de 0 a 255).
Cada vez que Mario d√° um Tornado Jump sobre o lago, o valor aumenta em 1.
O problema √© que esse valor n√£o tem limite definido (sem ‚Äúcap‚Äù) ‚Äî o que significa que ele continua subindo, mesmo ap√≥s o lago teoricamente ‚Äúquebrar‚Äù.</p>
<p>Quando o jogador usa o glitch para impedir o reset do mapa, o contador continua subindo indefinidamente ‚Äî e o jogo n√£o sabe lidar com esses valores ‚Äúilegais‚Äù.
Por isso, o lago passa a:

Mostrar texturas sobrepostas ou piscando (quando h√° mistura de estados como gelo e √°gua);

Ter colis√µes bugadas, permitindo que Mario ande sobre a √°gua ou caia num buraco invis√≠vel;

Desaparecer completamente ap√≥s muitos incrementos.</p>
<p>O sistema do jogo segue esta l√≥gica simplificada:

<p>if (Mario_uses_TornadoJump_on_pond) {</p>
    <p> pond_state += 1; // incrementa o estado do lago</p>
    <p>if (pond_state == 2) trigger_penguin_event();</p>
<p>}</p>


<p>E quando o jogador √© expulso do mapa:</p>

<p>reset_pond_state(); // retorna o estado para 0</p>


O loading zone storage cancela o reset_pond_state(), mas deixa pond_state como est√°.
Assim, o jogo continua aplicando o efeito de ‚Äú+1‚Äù sem nunca reiniciar, criando estados visuais e f√≠sicos que n√£o foram programados para existir.</p>
<p>Mostra uma falha cl√°ssica de design de vari√°veis: falta de ‚Äúlimite‚Äù para o contador (sem cap).

Permite acessar texturas e estados nunca vistos normalmente, como um terceiro est√°gio de rachadura e at√© um lago inexistente.

Demonstra como Paper Mario 64 manipula o ambiente de forma baseada em scripts simples, sem checagens de seguran√ßa ‚Äî algo que jogadores habilidosos podem explorar para criar efeitos inesperados.</p>
<br>
<br>

<h3><i>Odd Key early</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/pm/200px-PM_Odd_Key_Early.png">
<p>O Odd Key Early glitch em Paper Mario 64 √© um √≥timo exemplo de como pequenas falhas na detec√ß√£o de colis√£o e no gerenciamento da hitbox (√°rea de alcance) podem ser exploradas para burlar restri√ß√µes do jogo.</p>
<p>Normalmente, o Odd Key (Chave Estranha) s√≥ pode ser obtido ap√≥s entrar na casa onde ela est√°, algo que o jogo pretende impedir at√© certo ponto da hist√≥ria.
Por√©m, ao seguir uma sequ√™ncia espec√≠fica de movimentos, o jogador consegue ‚Äúenganar‚Äù o sistema de colis√£o do martelo de Mario:

O jogador posiciona Mario encostado na parede leste da casa (do lado de fora).

Ele usa o Spin Dash (a investida girat√≥ria) sem mudar de posi√ß√£o, o que inicia uma anima√ß√£o de movimento r√°pido.

Durante a anima√ß√£o ‚Äî antes que o giro termine ‚Äî o jogador rapidamente vira Mario para o lado oposto (oeste) e usa o martelo.

Se o tempo for perfeito, o martelo ignora a colis√£o da parede e ‚Äúatravessa‚Äù o objeto s√≥lido, atingindo a chave que est√° dentro da casa.</p>
<p>Esse glitch acontece por causa de uma falha no sincronismo entre a anima√ß√£o de movimento (Spin Dash) e o c√°lculo de colis√£o do martelo:

Durante o Spin Dash, o jogo desativa momentaneamente certas verifica√ß√µes de colis√£o para permitir que Mario acelere e gire livremente.

O martelo, por sua vez, √© programado para atingir qualquer objeto dentro de uma √°rea fixa na frente de Mario, sem verificar novamente se h√° uma parede bloqueando o alcance.

Quando o jogador ativa o martelo antes que o Spin Dash finalize, o jogo ainda considera Mario como estando em ‚Äúmovimento livre‚Äù e n√£o aplica as colis√µes de parede naquele quadro.

O resultado √© que o golpe do martelo ‚Äúatravessa‚Äù a parede e interage com o item que est√° do outro lado ‚Äî neste caso, a Odd Key.</p>
<p>Embora o jogador consiga pegar a chave mais cedo, a porta da casa ainda n√£o pode ser aberta, pois o jogo exige que ela seja destrancada por dentro.
Isso significa que o glitch s√≥ antecipa a coleta do item, mas n√£o quebra a sequ√™ncia de eventos principal.</p>
<p>Tipo de falha: colis√£o e sincroniza√ß√£o de anima√ß√µes.

Causa: o martelo verifica o alcance, mas n√£o a barreira f√≠sica, quando ativado durante o Spin Dash.

Efeito: permite ‚Äúestender‚Äù o golpe do martelo atrav√©s de paredes e coletar o item de forma antecipada.</p>
<br>
<br>

<h3><i>Out of bounds</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/pm/200px-PM_Outofbounds.png">
<p>O Out of Bounds glitch em Paper Mario 64 √© um dos tipos de falha mais comuns em jogos 3D ‚Äî e tamb√©m um dos mais interessantes para entender tecnicamente. Ele ocorre quando Mario sai dos limites da √°rea jog√°vel, e o jogo precisa decidir o que fazer com ele.</p>
<p>Em condi√ß√µes normais, o jogo mant√©m Mario dentro de uma √°rea delimitada por colis√µes invis√≠veis ‚Äî o chamado map boundary. Por√©m, usando certas manobras (como saltos com parceiros, Spin Dash, ou intera√ß√µes erradas com o cen√°rio), √© poss√≠vel ‚Äúescapar‚Äù dessas barreiras e cair no vazio (void).

Quando isso acontece, o jogo tenta corrigir a situa√ß√£o automaticamente, seguindo uma s√©rie de verifica√ß√µes internas:

Ele verifica se Mario ainda est√° acima de alguma superf√≠cie s√≥lida (collision floor).

Se estiver, o jogo recoloca Mario em cima dessa superf√≠cie.

Caso contr√°rio, o jogo tenta lev√°-lo de volta √† √∫ltima posi√ß√£o v√°lida registrada antes da queda.

Se essas verifica√ß√µes falharem, o comportamento se torna imprevis√≠vel ‚Äî e √© a√≠ que o glitch acontece.

Dependendo do local e da velocidade da queda, Mario pode atravessar o mapa, ficar suspenso no ar, ou at√© acessar √°reas que normalmente n√£o seriam alcan√ß√°veis.</p>
<p>A causa est√° na forma como o motor do jogo gerencia colis√µes e posi√ß√µes no espa√ßo 3D:

O mapa do jogo √© essencialmente uma ‚Äúcaixa‚Äù de pol√≠gonos, com √°reas s√≥lidas (onde h√° colis√£o) e vazias (onde n√£o h√°).

Quando Mario sai de uma √°rea com colis√£o, o jogo n√£o possui uma verifica√ß√£o imediata de ‚Äúmorte‚Äù ou rein√≠cio, como outros jogos fariam.

Em vez disso, ele tenta reposicionar Mario automaticamente, com base em uma l√≥gica de ‚Äúcorre√ß√£o‚Äù de posi√ß√£o.

Essa l√≥gica, no entanto, n√£o leva em conta limites verticais extremos, o que permite que o personagem caia al√©m do fundo do mapa e atinja regi√µes onde o jogo guarda dados tempor√°rios.</p>
<p>Uma curiosidade √© que o jogo armazena NPCs e inimigos cerca de 1.000 unidades abaixo da origem do mapa quando eles n√£o est√£o sendo usados.
Isso √© uma t√©cnica comum chamada object pooling ‚Äî usada para economizar processamento mantendo objetos ‚Äúadormecidos‚Äù fora da √°rea vis√≠vel.

Assim, quando Mario cai pr√≥ximo dessa regi√£o, √© poss√≠vel ver grupos de NPCs e inimigos juntos no vazio.
Em alguns casos, o jogador pode at√© iniciar batalhas contra inimigos ou chefes nesse local ‚Äî o que normalmente s√≥ aconteceria em cutscenes.
Quando isso acontece, o jogo toca a m√∫sica de batalha normal, j√° que o script da luta especial n√£o foi carregado.</p>
<p>Tipo de falha: erro de detec√ß√£o de colis√£o e posi√ß√£o fora dos limites.

Causa: aus√™ncia de verifica√ß√£o adequada de altura e colis√£o vertical.

Efeito: permite que Mario explore regi√µes fora do mapa, veja objetos ocultos e at√© entre em batalhas imprevistas.

Comportamento adicional: NPCs e inimigos ‚Äúarmazenados‚Äù aparecem a 1.000 unidades abaixo da origem do mapa.</p>
<br>
<br>

<h3><i>Harry's Shop out of bounds</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/pm/200px-PM_Harry_Shop_OoB.png">
<p>O Harry‚Äôs Shop Out of Bounds glitch em Paper Mario 64 √© um √≥timo exemplo de como o sistema de colis√£o e renderiza√ß√£o do jogo pode se comportar de forma inesperada quando o jogador sai dos limites previstos pelo mapa.</p>
<p>O jogador precisa ter acesso ao dep√≥sito da loja do Harry (a loja de badges em Toad Town).

Com o parceiro Parakarry, Mario pode ‚Äúclipar‚Äù (atravessar) a parede de tr√°s pr√≥xima √† roda no dep√≥sito ‚Äî uma √°rea onde as colis√µes foram mal ajustadas.

Uma vez fora do limite, o jogador pode se mover cuidadosamente pelo espa√ßo ‚Äúvazio‚Äù atr√°s das paredes, explorando √°reas que normalmente n√£o seriam acess√≠veis.

Se Mario cair nesse espa√ßo fora dos limites, o jogo detecta que ele n√£o est√° sobre uma superf√≠cie s√≥lida e, como mecanismo de seguran√ßa, o reposiciona de volta ao √∫ltimo ponto s√≥lido em que ele estava. Esse comportamento evita que o jogador trave o jogo, mas tamb√©m permite experimentar visualiza√ß√µes incomuns do mapa.

Quando o jogador consegue se manter no espa√ßo ‚Äúfora do mapa‚Äù, ele observa algo curioso:

Apenas a loja do Harry permanece vis√≠vel.

O restante da cidade (Toad Town) desaparece, pois o jogo para de renderizar as outras partes do cen√°rio.

No entanto, alguns objetos espec√≠ficos, como a mola que leva ao Shy Guy‚Äôs Toy Box, ainda aparecem se o jogador se aproximar da √°rea correspondente.

Se o jogador tentar entrar em outros pr√©dios nesse estado, as paredes permanecer√£o invis√≠veis, mas os objetos internos (como m√≥veis e NPCs) ainda estar√£o l√°.
Por exemplo, ao entrar no pr√©dio √† esquerda da loja, os Toads continuam invis√≠veis ‚Äî o jogo carrega seus dados, mas n√£o as texturas associadas √†quele cen√°rio.
Ao sair, Toad Town volta a aparecer normalmente, mas a loja de Harry permanece ‚Äúquebrada‚Äù, com falhas gr√°ficas e renderiza√ß√£o parcial.</p>
<p>Esse glitch acontece por uma combina√ß√£o de problemas de colis√£o e carregamento condicional de objetos:

Erro de colis√£o na parede do dep√≥sito

O jogo usa pol√≠gonos invis√≠veis para definir onde Mario pode ou n√£o passar.

Pr√≥ximo √† roda, h√° uma pequena brecha na colis√£o, permitindo que Mario e Parakarry ultrapassem o limite do cen√°rio.

Sistema de renderiza√ß√£o baseado em zonas

O jogo carrega e desenha apenas os objetos e partes do mapa que o jogador ‚Äúdeveria‚Äù estar vendo.

Ao sair dos limites, Mario se move para uma zona n√£o reconhecida pelo sistema de c√¢mera, fazendo o jogo n√£o renderizar a maior parte da cidade.

Apenas os modelos carregados no momento da sa√≠da (como a loja do Harry) continuam vis√≠veis.

Reposicionamento autom√°tico

Se Mario cair no vazio, o jogo tenta detectar a √∫ltima posi√ß√£o v√°lida.

Isso cria a sensa√ß√£o de ‚Äúvoltar‚Äù ao cen√°rio em vez de cair indefinidamente, o que mant√©m o glitch jog√°vel.

Desrefer√™ncia de objetos e texturas

Quando Mario reentra em pr√©dios enquanto o mapa est√° parcialmente descarregado, as refer√™ncias visuais (texturas) n√£o s√£o atualizadas corretamente.

O resultado √© que os NPCs e objetos existem, mas n√£o s√£o desenhados na tela.</p>
<p>Tipo de falha: clipping + falha de renderiza√ß√£o por zonas.

Causa: brecha na colis√£o do dep√≥sito e sistema de carregamento baseado em posi√ß√£o.

Efeito: partes do cen√°rio desaparecem, NPCs ficam invis√≠veis e a loja de Harry permanece ‚Äúbugada‚Äù at√© o mapa ser recarregado.

Curiosidade: esse glitch mostra claramente como Paper Mario divide seus mapas em blocos de carregamento e renderiza√ß√£o ‚Äî algo comum em jogos do Nintendo 64 para economizar mem√≥ria.</p>
<br>
<br>

<h3><i>Swim on land</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/pm/200px-PM_Sushie_Swim_on_Land.png">
<img width="70%" src="./src/assets/images/glitchesEBugs/pm/200px-PM_Toad_Town_swimming_on_land.png">
<p>O Swim on Land glitch em Paper Mario 64 √© um dos mais conhecidos e interessantes do jogo, pois permite que Mario nade em terra firme com a parceira Sushie, algo que normalmente s√≥ deveria ser poss√≠vel dentro d‚Äô√°gua. Esse glitch mistura erros de persist√™ncia de estado, falta de verifica√ß√£o de colis√£o correta, e comportamento incorreto da transi√ß√£o entre mapas.</p>
<p>Em determinadas √°reas, √© poss√≠vel ativar o glitch de modo que Mario e Sushie entrem no estado de nata√ß√£o em terra.
Isso ocorre quando o jogo n√£o reseta corretamente o ‚Äúestado de movimento‚Äù de Mario ao sair da √°gua, e o estado de ‚Äúnadando‚Äù permanece ativo mesmo ap√≥s carregar uma nova √°rea.

Quando Mario est√° montado na Sushie, o jogo muda sua movimenta√ß√£o para o modo de nata√ß√£o, desativando colis√µes de solo, escadas e rampas.

Por√©m, se o jogador sair da √°gua em um momento exato ‚Äî normalmente durante a troca de tela (loading zone) ‚Äî o jogo mant√©m o estado de ‚ÄúMario nadando‚Äù, mesmo que ele esteja agora sobre o ch√£o.

Assim, Mario parece flutuar e se mover como se ainda estivesse na √°gua, mas em plena terra.

O glitch pode persistir ao longo de v√°rias √°reas, desde que o jogador entre nelas por zonas de transi√ß√£o normais (portas, bordas de mapa etc.).</p>
<p>Mario e Sushie n√£o podem subir rampas, nem usar portas ou canos, j√° que o modo de nata√ß√£o desativa esses tipos de intera√ß√£o.

Entretanto, o jogador pode mergulhar sob obst√°culos ou at√© sair dos limites do mapa, nadando ‚Äúpor baixo‚Äù das barreiras e reaparecendo do outro lado.

Inimigos n√£o perseguem Mario nesse estado, pois a IA deles √© programada para ignorar Mario enquanto ele est√° montado em Sushie.

Se o jogador encontrar um inimigo e terminar a batalha com Sushie ainda ativa, o glitch √© temporariamente desativado. Mas ele reativa automaticamente ao trocar de tela novamente.

Por outro lado, h√° um risco:
üëâ Se o jogador enfrentar tr√™s inimigos seguidos na mesma sala sem trocar de tela, o jogo entra em softlock (congela).
Isso acontece porque o contador interno de ‚Äúcutscenes ativas‚Äù subtrai um valor incorretamente, gerando um underflow ‚Äî ou seja, o contador vai para um n√∫mero negativo que o jogo n√£o consegue interpretar.

O glitch termina se Mario:

Retorna a um p√≠er ou doca (onde Sushie √© programada para desmontar automaticamente);

Ou troca de parceiro ap√≥s uma batalha.</p>
<p>O Swim on Land glitch √© resultado de tr√™s sistemas do jogo interagindo de forma incorreta:

Persist√™ncia de estado incorreta

O jogo usa um valor interno para marcar o ‚Äúestado atual‚Äù de Mario (andar, pular, nadar, conversar, etc.).

Quando o jogador muda de tela enquanto ainda est√° montado em Sushie antes que o jogo redefina o estado, o novo mapa √© carregado sem resetar o estado de nata√ß√£o.

Aus√™ncia de checagem de terreno ap√≥s carregamento

Ao carregar uma nova √°rea, o jogo n√£o verifica se o ch√£o sob Mario √© √°gua ou terra.

Isso faz com que Mario ‚Äúcontinue nadando‚Äù mesmo sobre um terreno s√≥lido.

IA dos inimigos e flags de colis√£o desativadas

O modo ‚ÄúMario montado em Sushie‚Äù desativa colis√µes com certos objetos e faz os inimigos ignorarem Mario.

Isso explica por que ele pode atravessar paredes, nadar sob o mapa e n√£o ser detectado por inimigos.

Underflow de cutscenes

O sistema de batalhas usa um contador de eventos (cutscenes) que deve zerar ap√≥s cada luta.

Quando Mario est√° em estado incorreto (nadando no ch√£o), o jogo n√£o remove corretamente o valor do contador, e depois de algumas batalhas, ele transborda e trava.</p>
<p>Tipo de falha: erro de persist√™ncia de estado + aus√™ncia de verifica√ß√£o de terreno + underflow de vari√°veis.

Causa principal: transi√ß√£o de mapa antes do jogo redefinir o estado de nata√ß√£o de Mario.

Efeitos: Mario e Sushie nadam sobre o ch√£o, ignoram colis√µes, ficam invis√≠veis para inimigos e podem atravessar o cen√°rio.

Riscos: o jogo pode travar ap√≥s m√∫ltiplas batalhas consecutivas nesse estado.

Corre√ß√£o natural: trocar de parceiro ou retornar √† √°gua.</p>
<br>
<br>

<h3><i>Shiver Snowfield letter crash</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/pm/200px-PM_Shiver_Snowfield_Letter_Crash.png">
<p>O glitch ‚ÄúShiver Snowfield letter crash‚Äù em Paper Mario 64 acontece devido a uma falha de l√≥gica no script respons√°vel por controlar a anima√ß√£o da carta caindo.</p>
<p>Em Shiver Snowfield, h√° uma carta escondida em uma √°rvore. Quando Mario bate na √°rvore, a carta cai lentamente at√© o ch√£o. Por√©m, se o jogador for r√°pido o suficiente e pegar a carta antes que ela toque o solo, o jogo tenta executar uma parte do c√≥digo que ainda depende da queda estar completa ‚Äî algo que n√£o aconteceu.</p>
<p>O jogo usa um pinguim invis√≠vel para calcular a trajet√≥ria da carta enquanto ela cai. Basicamente, a posi√ß√£o da carta est√° sendo mapeada √†s coordenadas desse pinguim invis√≠vel.
Quando o jogador coleta a carta cedo demais, o script tenta continuar manipulando a posi√ß√£o do pinguim (que j√° n√£o deveria mais existir ou estar ativo), o que causa um erro de acesso √† mem√≥ria ‚Äî um ‚ÄúTLB Exception On Store‚Äù. Esse √© um tipo de falha comum em jogos do Nintendo 64 quando o c√≥digo tenta escrever dados em um endere√ßo de mem√≥ria inv√°lido.</p>
<p>O jogo cria um pinguim invis√≠vel para animar a carta.

A carta deve tocar o ch√£o antes de ser coletada.

Se for coletada antes, o script tenta acessar o pinguim j√° removido.

Isso faz o jogo travar (crashar) com o erro ‚ÄúTLB Exception On Store‚Äù.</p>
<br>
<br>

<h3><i>Herringway visited early</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/pm/200px-PM_warehouse_clip.gif">
<p>O glitch ‚ÄúHerringway visited early‚Äù em Paper Mario 64 permite que Mario acesse a casa do personagem Herringway antes do momento correto na hist√≥ria, pulando parte do enredo do ‚Äúmist√©rio do assassinato do pinguim‚Äù.</p>
<p>Na cidade de Shiver City, h√° um armaz√©m trancado que normalmente s√≥ pode ser aberto depois de pegar a Warehouse Key (chave) encontrada em um lago congelado. No entanto, √© poss√≠vel explorar uma falha de colis√£o no canto esquerdo do armaz√©m.
Se o jogador posicionar Mario levemente dentro da quina e montar no parceiro Lakilester, ele consegue atravessar (‚Äúclipar‚Äù) a parede e entrar no armaz√©m, mesmo sem a chave.</p>
<p>Na cidade de Shiver City, h√° um armaz√©m trancado que normalmente s√≥ pode ser aberto depois de pegar a Warehouse Key (chave) encontrada em um lago congelado. No entanto, √© poss√≠vel explorar uma falha de colis√£o no canto esquerdo do armaz√©m.
Se o jogador posicionar Mario levemente dentro da quina e montar no parceiro Lakilester, ele consegue atravessar (‚Äúclipar‚Äù) a parede e entrar no armaz√©m, mesmo sem a chave.</p>
<p>O jogador entra no armaz√©m sem precisar da chave.

A c√¢mera permanece do lado de fora, pois o jogo n√£o foi programado para mostrar o interior nessa situa√ß√£o.

Apesar disso, o jogador pode alcan√ßar o trampolim que leva √† chamin√© de Herringway.

Ao entrar na casa, ela aparece completamente escura, porque a ilumina√ß√£o do interior s√≥ √© carregada quando o acesso √© feito normalmente.

Falar com Herringway atualiza o progresso da hist√≥ria, permitindo avan√ßar o enredo antes do previsto ‚Äî pulando toda a primeira parte do mist√©rio.</p>
<p>H√° uma falha de colis√£o no canto do armaz√©m.

O uso de Lakilester altera temporariamente a posi√ß√£o de Mario, permitindo atravessar a parede.

O jogo carrega √°reas e scripts fora de ordem, resultando em bugs visuais (como a escurid√£o) e avan√ßos de hist√≥ria indevidos.</p>
<p>Esse glitch √© um √≥timo exemplo de como pequenas falhas em colis√µes 3D podem ser exploradas para sequence breaks (quebras de sequ√™ncia), algo comum em speedruns de jogos do Nintendo 64.</p>
<br>
<br>

<h3><i>Peach in Bowser's Castle</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/pm/200px-PM_Peach_Bowser's_Castle_battle.png">
<p>O glitch ‚ÄúPeach in Bowser‚Äôs Castle‚Äù em Paper Mario 64 √© um dos mais curiosos do jogo, pois permite que a Princesa Peach ‚Äî personagem normalmente limitada √†s suas se√ß√µes de interl√∫dio ‚Äî entre no castelo de Bowser, algo totalmente imposs√≠vel no jogo original sem usar falhas na l√≥gica de sequ√™ncia.</p>
<p>Durante o interl√∫dio do Cap√≠tulo 6, Peach pode sair do Castelo dela disfar√ßada com o Sneaky Parasol, depois de receber uma chave da entrada de um Koopatrol. Essa √© a √∫nica vez no jogo em que ela pode deixar o seu castelo. Se o jogador tentar entrar na porta de Bowser‚Äôs Castle, Twink impede, dizendo que a porta est√° trancada.

O glitch acontece quando o jogador usa quebras de sequ√™ncia (‚Äúsequence breaks‚Äù) ‚Äî ou seja, manipula a ordem dos eventos do jogo. Se o jogador termina o Cap√≠tulo 6 e depois for√ßa o jogo a repetir um interl√∫dio anterior da Peach (por meio de outros glitches ou manipula√ß√£o de save), o jogo ‚Äúse confunde‚Äù:

Ele mant√©m as portas destrancadas de interl√∫dios anteriores.

E n√£o reativa o bloqueio de Twink.

Assim, Peach pode sair livremente e entrar em Bowser‚Äôs Castle, algo que o jogo n√£o deveria permitir.</p>
<p>O erro est√° na l√≥gica de eventos e flags do jogo:

Cada interl√∫dio da Peach tem suas pr√≥prias vari√°veis de progresso, indicando o que est√° trancado ou destrancado.

Normalmente, quando um interl√∫dio termina, essas flags s√£o reiniciadas.

Mas se o jogador volta a um interl√∫dio anterior fora de ordem, as flags de portas abertas permanecem ativas, e o bloqueio da entrada do castelo n√£o √© verificado novamente.

Em outras palavras, Peach consegue sair porque o jogo acredita que a porta ainda est√° aberta de um evento anterior e n√£o sabe que deveria impedir sua entrada em Bowser‚Äôs Castle.</p>
<p>Como os desenvolvedores nunca programaram intera√ß√µes da Peach dentro do castelo de Bowser, diversos comportamentos bugados ocorrem:

Inimigos e NPCs tratam Peach como se fosse o Mario.

Entrar em batalhas causa travamentos (crashes), pois Peach n√£o tem anima√ß√µes de dano ‚Äî o jogo tenta exibir uma que n√£o existe.

Se um inimigo acerta um First Strike, o jogo trava pelo mesmo motivo.

Peach pode dormir em uma cela, mas parte de seu sprite desaparece na anima√ß√£o.

Empurrar blocos de Bowser tamb√©m trava o jogo.

Se o Jr. Troopa ainda n√£o foi derrotado, ele aparecer√° para lutar ‚Äî o que tamb√©m causa travamento.

Ela s√≥ consegue chegar at√© a sala dos Bullet Bill Blasters, pois o design estreito impede a passagem.</p>
<p>O jogo foi feito assumindo que Peach nunca poderia sair do castelo depois do Cap√≠tulo 6, ent√£o nada foi programado para essa situa√ß√£o. Quando o jogador ‚Äúenganha‚Äù o sistema e for√ßa o jogo a permitir isso, o motor do jogo n√£o sabe como reagir ‚Äî resultando em uma das falhas mais bizarras e inst√°veis de Paper Mario 64.</p>
<br>
<br>

<h3><i>Peach in Bowser's Castle</i></h3>
<img width="70%" src="./src/assets/images/glitchesEBugs/pm/200px-PM_Peach_fighting_Bowser.png">
<p>O glitch ‚ÄúPeach fighting Bowser‚Äù em Paper Mario 64 √© uma continua√ß√£o do glitch que permite que Peach entre no castelo de Bowser. Ele acontece quando a Peach chega a uma situa√ß√£o que o jogo n√£o deveria jamais permitir, ou seja, lutar contra Bowser diretamente como Peach.</p>
<p>Entrada em Bowser‚Äôs Castle como Peach:

Usando a sequ√™ncia de glitches do interl√∫dio do Cap√≠tulo 6, Peach consegue entrar no castelo, algo que normalmente n√£o √© permitido.

Saindo pelo lado errado ou avan√ßando o storyline:

Ao sair do castelo pela porta de tr√°s ou chegar ao topo sem seguir o fluxo normal, o jogo define automaticamente o progresso da hist√≥ria como estado de ‚Äúfinal de jogo‚Äù.

Isso remove todos os guardas, altera a m√∫sica de fundo para a m√∫sica do endgame e faz NPCs reagirem como se Peach fosse Mario.

Chegando √† batalha contra Bowser:

Se Bowser n√£o foi derrotado anteriormente, ele aparecer√° e iniciar√° a batalha contra Peach.

Se o jogador tenta usar Twink para atac√°-lo, Twink voa e n√£o retorna, causando softlock.

Se Bowser j√° foi derrotado anteriormente, Peach pode prosseguir at√© a batalha final.</p>
<p>O problema central √© que Peach nunca foi programada para lutar contra Bowser. O motor do jogo assume que apenas Mario est√° ativo nas batalhas principais. Consequentemente:

As anima√ß√µes de dano e efeitos de status (como envenenamento) n√£o existem para Peach, ou s√£o mal processadas.

O jogo usa vari√°veis de Mario (HP, comandos de batalha) para a Peach, resultando em crashes ou softlocks.

Ataques espec√≠ficos de Bowser (como o ataque de fogo) tentam executar fun√ß√µes que Peach n√£o possui, causando travamentos imediatos.

Outros ataques (stomp, claw) afetam Peach de formas inesperadas:

Claw: descolore o sprite e aplica envenenamento que n√£o √© processado corretamente.

Stomp: remove comandos de batalha que Peach nem tem, mas a batalha continua.

Em resumo, o glitch explora o fato de que o jogo n√£o tem nenhuma rotina para Peach participando de batalhas normais ou finais, e tenta usar a l√≥gica de Mario para ela.</p>
<p>Al√©m disso:

Guardas e NPCs n√£o aparecem corretamente.

Objetos interativos, como espelhos ou camas, usam textos e anima√ß√µes de Mario.

A m√∫sica de fundo muda para o estado final do jogo.</p>
<p>Tipo de falha: Falta de programa√ß√£o para Peach em batalhas principais.

Causa: O jogo assume que apenas Mario pode lutar contra Bowser; todas as vari√°veis e anima√ß√µes de Peach n√£o existem para isso.

Efeito principal: Permite que Peach entre no castelo e lute contra Bowser, causando crashes e softlocks.

Por que funciona: Sequence breaks e manipula√ß√£o de flags permitem que Peach alcance √°reas que o jogo n√£o deveria deixar; o motor tenta trat√°-la como Mario, mas sem suporte completo.

üß† Em ess√™ncia: Peach lutando contra Bowser √© totalmente n√£o planejado pelos desenvolvedores, e o glitch √© um exemplo cl√°ssico de ‚Äúunexpected behavior‚Äù causado pela aus√™ncia de c√≥digo para uma situa√ß√£o imposs√≠vel no fluxo normal do jogo.</p>
<br>
<br>
